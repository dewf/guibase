module Drawing;

import Foundation;

struct Point {
    double x;
    double y;
}

struct Size {
    double width;
    double height;
}

struct Rect {
    Point origin;
    Size size;
}

struct AffineTransform {
    double a;
    double b;
    double c;
    double d;
    double tx;
    double ty;
}
AffineTransform AffineTransformIdentity;

enum PathDrawingMode {
    Fill,
    EOFill,
    Stroke,
    FillStroke,
    EOFillStroke
}

// a way of handling optional args until we come up with something direct?
options OptArgs {
    AffineTransform transform;
}


// ideally these would be directly accessible as Color::White etc - like global constants, but namespaced under the opaque
// ColorSpaces should have the same thing: ColorSpace::GenericGray etc
// hmm but what if they are expensive to create? no idea if they are or not ...
// and if we're maintaining them then we're going to see them as leaks on the C++ size, since they would last the entire program
// unless they were explicitly disposed in the module shutdown ...
// lazy initialization perhaps? looks like a property but is actually a function?

enum ColorConstants {
    White,
    Black,
    Clear
}

opaque Color {
    static Color createGenericRGB(double red, double green, double blue, double alpha);
    static Color getConstantColor(ColorConstants which);
}

sumtype ColorSpaceName {
    GenericGray,
    GenericRGB,
    GenericCMYK,
    GenericRGBLinear,
    AdobeRGB1998,
    SRGB,
    GenericGrayGamma2_2,
    //
    Other(string name)
}

opaque ColorSpace {
    static ColorSpace createWithName(ColorSpaceName name);
    static ColorSpace createDeviceGray();
}

flags GradientDrawingOptions {
    DrawsBeforeStartLocation = 1 << 0,
    DrawsAfterEndLocation = 1 << 1
}

struct GradientStop {
    double location;
    double red;
    double green;
    double blue;
    double alpha;
}

opaque Gradient {
    static Gradient createWithColorComponents(ColorSpace space, Array<GradientStop> stops);
}

opaque Path {
    static Path createWithRect(Rect rect, OptArgs optArgs);
    static Path createWithEllipseInRect(Rect rect, OptArgs optArgs);
    static Path createWithRoundedRect(Rect rect, double cornerWidth, double cornerHeight, OptArgs optArgs);
}

opaque DrawContext {
    void saveGState();
    void restoreGState();
    void setRGBFillColor(double red, double green, double blue, double alpha);
    void setRGBStrokeColor(double red, double green, double blue, double alpha);
    void fillRect(Rect rect);
    void setTextMatrix(AffineTransform t);
    void setTextPosition(double x, double y);
    void beginPath();
    void addArc(double x, double y, double radius, double startAngle, double endAngle, bool clockwise);
    void addArcToPoint(double x1, double y1, double x2, double y2, double radius);
    void drawPath(PathDrawingMode mode);
    void setStrokeColorWithColor(Color color);
    void strokeRectWithWidth(Rect rect, double width);
    void moveToPoint(double x, double y);
    void addLineToPoint(double x, double y);
    void strokePath();
    void setLineDash(double phase, Array<double> lengths);
    void clearLineDash();                           // maybe until we have an Option<> type or something to use in setLineDash()
    void setLineWidth(double width);
    void clip();
    void clipToRect(Rect clipRect);
    void translateCTM(double tx, double ty);
    void scaleCTM(double scaleX, double scaleY);
    void rotateCTM(double angle);
    void concatCTM(AffineTransform transform);
    void addPath(Path path);
    void fillPath();
    void strokeRect(Rect rect);
    void addRect(Rect rect);
    void closePath();
    void drawLinearGradient(Gradient gradient, Point startPoint, Point endPoint, GradientDrawingOptions drawOpts);
}

// text stuff

options AttributedStringOptions {
    Color foregroundColor;
    bool foregroundColorFromContext;
    Font font;
    double strokeWidth;
    Color strokeColor;
}

opaque AttributedString {
    static AttributedString create(string s, AttributedStringOptions opts);
}

opaque Font {
    static Font createFromFile(string path, double size, OptArgs optArgs);
    static Font createWithName(string name, double size, OptArgs optArgs);
}

struct TypographicBounds {
    double width;
    double ascent;
    double descent;
    double leading;
}

flags LineBoundsOptions {
    ExcludeTypographicLeading  = 1 << 0,
    ExcludeTypographicShifts   = 1 << 1,
    UseHangingPunctuation      = 1 << 2,
    UseGlyphPathBounds         = 1 << 3,
    UseOpticalBounds           = 1 << 4
}

opaque Line {
    TypographicBounds getTypographicBounds();
    Rect getBoundsWithOptions(LineBoundsOptions opts);
    void draw(DrawContext context);

    static Line createWithAttributedString(AttributedString str);
}
