module Drawing;

struct Point {
    double x;
    double y;
}

struct Size {
    double width;
    double height;
}

struct Rect {
    Point origin;
    Size size;
}

struct AffineTransform {
    double a;
    double b;
    double c;
    double d;
    double tx;
    double ty;
}
AffineTransform AffineTransformIdentity;

enum PathDrawingMode {
    Fill,
    EOFill,
    Stroke,
    FillStroke,
    EOFillStroke
}

// a way of handling optional args until we come up with something direct?
options OptArgs {
    AffineTransform transform;
}


// ideally these would be directly accessible as Color::White etc - like global constants, but namespaced under the opaque
// ColorSpaces should have the same thing: ColorSpace::GenericGray etc
// hmm but what if they are expensive to create? no idea if they are or not ...
// and if we're maintaining them then we're going to see them as leaks on the C++ size, since they would last the entire program
// unless they were explicitly disposed in the module shutdown ...
// lazy initialization perhaps? looks like a property but is actually a function?

enum ColorConstants {
    White,
    Black,
    Clear
}

opaque Color {
    static Color createGenericRGB(double red, double green, double blue, double alpha);
    static Color getConstantColor(ColorConstants which);
}

enum ColorSpaceName {
    GenericGray,
    GenericRGB,
    GenericCMYK,
    GenericRGBLinear,
    AdobeRGB1998,
    SRGB,
    GenericGrayGamma2_2
    // many more we don't have yet!
}

opaque ColorSpace {
    static ColorSpace createWithName(ColorSpaceName name);
    static ColorSpace createDeviceGray();
}

flags GradientDrawingOptions {
    DrawsBeforeStartLocation = 1 << 0,
    DrawsAfterEndLocation = 1 << 1
}

struct GradientStop {
    double location;
    double red;
    double green;
    double blue;
    double alpha;
}

opaque Gradient {
    static Gradient createWithColorComponents(ColorSpace space, Array<GradientStop> stops);
}

opaque Path {
    static Path createWithRect(Rect rect, OptArgs optArgs);
    static Path createWithEllipseInRect(Rect rect, OptArgs optArgs);
    static Path createWithRoundedRect(Rect rect, double cornerWidth, double cornerHeight, OptArgs optArgs);
}

opaque DrawContext {
    void saveGState();
    void restoreGState();
    void setRGBFillColor(double red, double green, double blue, double alpha);
    void setRGBStrokeColor(double red, double green, double blue, double alpha);
    void fillRect(Rect rect);
    void setTextMatrix(AffineTransform t);
    void setTextPosition(double x, double y);
    void beginPath();
    void addArc(double x, double y, double radius, double startAngle, double endAngle, bool clockwise);
    void addArcToPoint(double x1, double y1, double x2, double y2, double radius);
    void drawPath(PathDrawingMode mode);
    void setStrokeColorWithColor(Color color);
    void strokeRectWithWidth(Rect rect, double width);
    void moveToPoint(double x, double y);
    void addLineToPoint(double x, double y);
    void strokePath();
    void setLineDash(double phase, Array<double> lengths);
    void clearLineDash();                           // maybe until we have an Option<> type or something to use in setLineDash()
    void setLineWidth(double width);
    void clip();
    void clipToRect(Rect clipRect);
    void translateCTM(double tx, double ty);
    void scaleCTM(double scaleX, double scaleY);
    void rotateCTM(double angle);
    void concatCTM(AffineTransform transform);
    void addPath(Path path);
    void fillPath();
    void strokeRect(Rect rect);
    void addRect(Rect rect);
    void closePath();
    void drawLinearGradient(Gradient gradient, Point startPoint, Point endPoint, GradientDrawingOptions drawOpts);
}

// text stuff

options AttributedStringOptions {
    Color foregroundColor;
    bool foregroundColorFromContext;
    Font font;
    double strokeWidth;
    Color strokeColor;

    // for custom types, this seems the simplest for now:
    // client will maintain its own ID->value mapping, instead of having to have knowledge of CFDictionary types etc
    // because Core Text ultimately returns a CFDictionary for us for each "run", there's really no way to inject anything with higher level behavior.
    // for example if we wanted a single C# dictionary per run, because CoreText doesn't know anything about client-side data structures, and can't build them up
    // during run analysis - but it can certainly deal with ints! and we can use those to construct our own queryable things per run
    // another option would have been approximating CF* types via a sumtype, and storing things that way.
    // but ints yield greater flexibiliy, because we can store absolutely whatever on the client side instead (not limiting us to known CF* types)
}

sumtype Range {
    NotFound,
    Zero,
    Valid(long location, long length)
}

opaque AttributedString {
    static AttributedString create(string s, AttributedStringOptions opts);
}

opaque MutableAttributedString { // todo: inherit from AttributedString, meaning the backend can operate on it that way as well
    // AttributedString methods, actually:
    long getLength();

    // Mutable methods:
    void replaceString(Range range, string str);
    void beginEditing();
    void endEditing();
    void setAttribute(Range range, AttributedStringOptions attr);
    void setCustomAttribute(Range range, string key, long value); // ID key has client-specific meaning (use a dictionary or something)

    // temporary, until we get inheritance working
    AttributedString getNormalAttributedString_REMOVEME();

    static MutableAttributedString create(long maxLength);
}

options FontTraits {
    bool italic;
    bool bold;
    bool expanded;
    bool condensed;
    bool monospace;
    bool vertical;
    // some others not yet put here
}

opaque Font {
    Font createCopyWithSymbolicTraits(double size, FontTraits newTraits, OptArgs optArgs); // optional matrix was originally next-to-last argument
    double getAscent();
    double getDescent();
    double getUnderlineThickness();
    double getUnderlinePosition();

    static Font createFromFile(string path, double size, OptArgs optArgs);
    static Font createWithName(string name, double size, OptArgs optArgs);
}

struct TypographicBounds {
    double width;
    double ascent;
    double descent;
    double leading;
}

flags LineBoundsOptions {
    ExcludeTypographicLeading  = 1 << 0,
    ExcludeTypographicShifts   = 1 << 1,
    UseHangingPunctuation      = 1 << 2,
    UseGlyphPathBounds         = 1 << 3,
    UseOpticalBounds           = 1 << 4
}

flags RunStatus {
    NoStatus = 0,
    RightToLeft = 1 << 0,
    NonMonotonic = 1 << 1,
    HasNonIdentityMatrix = 1 << 2
}

opaque Run {
    AttributedStringOptions getAttributes();
    Map<string,long> getCustomAttributes(Array<string> keys);
    TypographicBounds getTypographicBounds(Range range);
    Range getStringRange();
    RunStatus getStatus();
}

opaque Line {
    TypographicBounds getTypographicBounds();
    Rect getBoundsWithOptions(LineBoundsOptions opts);
    void draw(DrawContext context);
    Array<Run> getGlyphRuns();
    Tuple<double,double> getLineOffsetForStringIndex(long charIndex); // offset + secondaryOffset

    static Line createWithAttributedString(AttributedString str);
}

opaque Frame {
    void draw(DrawContext context);
    Array<Line> getLines();
    Array<Point> getLineOrigins(Range range); // zero range = fetch all
}

opaque FrameSetter {
    static FrameSetter createWithAttributedString(AttributedString str);
    Frame createFrame(Range range, Path path); // no frameAttributes yet, not sure what they are!
}
